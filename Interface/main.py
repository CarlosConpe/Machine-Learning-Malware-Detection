# Importing the classes where we develop the backend (Machine learning models and implementations).
from classes.DataParser import *
from classes.MachineLearningModel import *
from classes.ConvolutionalNeuralNetwork import *
from classes.NeuralNetwork import *
from classes.GradientBoostingMachine import *
from classes.SupportVectorMachine import *
# Importing the packages to develop the interface.
import sys
import tkinter as tk
from tkinter import filedialog, ttk
from PIL import ImageTk, Image
from threading import *
import random
import time

# Machine learning:
import tensorflow as tf
import matplotlib.pyplot as plt

# Values to set the windows of the interface and flags to control the flow.
WIDTH_WINDOW = 900
HEIGHT_WINDOW = 475
flag_dataset = False
flag_compilado = False
flag_entrenado = False
flag_evaluacion = False
folder_selected = ""
# Global variables
global menu
global our_parser
global ai_models

# Main class, give the main methods to inherit to the other classes
# where the interface is developed, to create windows.


class App(ttk.Frame):
    global WIDTH_WINDOW, HEIGHT_WINDOW, flag_dataset, flag_compilado, flag_entrenado, folder_selected

    green_check_images = [None, None, None]
    main_window = tk.Tk()

    def __init__(self, title, color):
        super().__init__(self.main_window)
        self.main_window.title(title)
        self.main_window.configure(
            width=WIDTH_WINDOW, height=HEIGHT_WINDOW, bg=color)
        self.folder_selected = folder_selected

    def make_label(self, x, y, w, h, *args, **kwargs):
        """This method create a label, set it up to put it in
        the specified coordenates, with the selected width and height.

        Args:
            x (int): x position in the window.
            y (int): y position in the window.
            w (int): width of the label.
            h (int): height of the label.

        Returns:
            label: the label created
        """
        frame = ttk.Frame(self.main_window, height=h, width=w)
        frame.pack_propagate(True)
        frame.place(x=x, y=y)
        label = ttk.Label(frame, *args, **kwargs, wraplength=w)
        label.pack(fill=tk.BOTH, expand=False)
        return label

    def make_button(self, x, y, w, h, button_text, func=exit, *args, **kwargs):
        """This method create a button, set it up to put it in
        the specified coordenates, with the selected width and height.

        Args:
            x (int): x position in the window.
            y (int): y position in the window.
            w (int): width of the button.
            h (int): height of the button.
            button_text(string): The text inside the button.

        Returns:
            button: the button created
        """
        button = ttk.Button(
            self.main_window, text=button_text, command=func, *args, **kwargs
        )
        button.place(x=x, y=y, width=w, height=h)
        return button

    def make_image(self, x, y, image):
        """Select an image from the directory, create the image and 
        set it up in the coordenates selected.

        Args:
            x (int): x position.
            y (int): y position.
            image (string): Direction of the file.

        Returns:
            Image: The image selected from the directory.
        """
        image = Image.open(image)
        render = ImageTk.PhotoImage(image)
        img = ttk.Label(self.main_window, image=render)
        img.image = render
        img.place(x=x, y=y)
        return img

    def exit(self):
        """To close the window, it destroys the object.
        """
        
        self.main_window.destroy()
        self.main_window.quit()


    def check_steps(self):
        """This method check what buttons have been selected and if the
        order of selection is the correct, the flags of control flow are
        used here.
        """
        global flag_dataset, flag_compilado, flag_entrenado

        if flag_dataset and isinstance(self.green_check_images[0], type(None)):
            self.green_check_images[0] = self.make_image(
                350, 153, "./Images/check_small.png"
            )
        if (
            flag_entrenado
            and flag_compilado
            and isinstance(self.green_check_images[1], type(None))
        ):
            self.green_check_images[1] = self.make_image(
                350, 203, "./Images/check_small.png"
            )
        if flag_evaluacion and isinstance(self.green_check_images[2], type(None)):
            self.green_check_images[2] = self.make_image(
                350, 253, "./Images/check_small.png"
            )

        if not flag_dataset and not isinstance(self.green_check_images[0], type(None)):
            self.green_check_images[0].destroy()
            self.green_check_images[0] = None
        if (
            not flag_entrenado
            and not flag_compilado
            and not isinstance(self.green_check_images[1], type(None))
        ):
            self.green_check_images[1].destroy()
            self.green_check_images[1] = None
        if not flag_evaluacion and not isinstance(
            self.green_check_images[2], type(None)
        ):
            self.green_check_images[2].destroy()
            self.green_check_images[2] = None

# Here we create the window that is the main interface, we can select
# from here the next steps like charge the dataset, train and compile models,
# and evaluate the models.


class Main_window(App):
    def __init__(self, title, color):
        App.__init__(self, title, color)
        self.add_widgets()

    def window_load_dataset_show(self):
        """Method to set the dataset and charge the data parser,
        also the flags are reseted to start a new experiment.
        """
        global folder_selected, flag_dataset, flag_entrenado, flag_compilado, flag_evaluacion, menu, our_parser
        # flags reset.
        folder_selected = ""
        flag_dataset = False
        flag_compilado = False
        flag_entrenado = False
        flag_evaluacion = False

        dataset_information = {
            # SELECT HERE THE PATH FOR THE MALWARE DATASET:
            'src': './datasets/MalwareData.csv',
            # Do not change sep, the only thing you should change is the 'src' key to wherever your Malware dataset file is
            'sep': '|'
        }
        # We create an instance of our data parser bound to dataset_information
        our_parser = DataParser(dataset_information)
        if our_parser:
            # Parser creates training and testing dataset from original dataset
            our_parser.preprocess(training=0.7, testing=0.3)
            flag_dataset = True
        else:
            our_parser = None
            flag_dataset = False

        menu.check_steps()

    def window_compile_train_show(self):
        """Creates the window to compile and train.
        Verifies if the dataset is selected.

        Returns:
            window: The secondary window Compile and Train.
        """
        global flag_dataset, flag_entrenado, flag_compilado, menu

        if flag_dataset:
            window = Compile_train_window("Compilar y Entrenar", "#ECECEC")
            menu.check_steps()
            return window
        else:
            self.window_load_dataset_show()
            if flag_dataset:
                window = Compile_train_window("Compilar y Entrenar", "#ECECEC")
                menu.check_steps()
                return window
        return

    def window_evaluate_show(self):
        """Creates the window to Evaluate.
        Verifies if the compile and train process have been done.

        Returns:
            window: The secondary window Evaluate.
        """
        global flag_dataset, flag_entrenado, flag_compilado, menu

        if flag_compilado and flag_entrenado:
            window = Evaluate_window("Evaluar", "#ECECEC")
            menu.check_steps()
            return window
        else:
            self.window_compile_train_show()

    def restablecer_parametros_iniciales(self):
        """Reset the parameters of the control flags to be able to start
        a new experiment, resets the dataset.
        """
        global folder_selected, flag_dataset, flag_entrenado, flag_compilado, flag_evaluacion, menu
        folder_selected = ""
        flag_dataset = False
        flag_compilado = False
        flag_entrenado = False
        flag_evaluacion = False
        menu.check_steps()

    def add_widgets(self):
        """Setting the labels, images and buttons of the main window
        to create the user interface.
        """
        self.make_label(
            40,
            40,
            300,
            100,
            text="Clasificación de Malware Mediante Deep Learning",
            background="white",
            font=("Arial", 19),
        )
        self.make_button(
            40, 150, 300, 40, "Cargar Dataset", self.window_load_dataset_show
        )
        self.make_button(
            40, 200, 300, 40, "Compilar y Entrenar", self.window_compile_train_show
        )
        self.make_button(40, 250, 300, 40, "Evaluar",
                         self.window_evaluate_show)
        self.make_button(40, 400, 100, 40, "Salir", self.exit)
        self.make_button(
            150, 400, 190, 40, "Restablecer", self.restablecer_parametros_iniciales
        )
        self.make_image(500, 60, "./Images/uaslp.jpg")

# This class inherit from the App class, is used to create the secondary windows like
# the Compile and train window, the evaluation window.


class Secondary_window(App):
    global WIDTH_WINDOW, HEIGHT_WINDOW, flag_dataset, flag_compilado, flag_entrenado, folder_selected

    def __init__(self, title, color):
        self.main_window = tk.Toplevel()
        App.__init__(self, title, color)

    def exit(self):
        self.main_window.withdraw()

# This class inherit from the previous class secondary window, is used to creat the
# Compile and train window.


class Compile_train_window(Secondary_window):
    model_progresses_compile = []  # To set the progress bars.
    model_progresses_train = []  # """"""

    threads_compile = []
    threads_train = []

    def __init__(self, title, color):
        Secondary_window.__init__(self, title, color)
        self.provisional_height = HEIGHT_WINDOW + 40 * 2
        self.main_window.configure(
            width=WIDTH_WINDOW, height=self.provisional_height, bg=color
        )
        self.model_progresses_compile = []
        self.model_progresses_train = []
        self.threads_compile = []
        self.threads_train = []
        self.load_widgets()

    def load_widgets(self):
        """Creates the user interface of this window.
        """
        self.make_label(
            40,
            40,
            WIDTH_WINDOW - 100,
            50,
            text="Estatus",
            background="white",
            font="Arial 12 bold",
        )

        self.make_button(
            WIDTH_WINDOW - 150,
            self.provisional_height - 65,
            100,
            40,
            "Salir",
            self.exit,
        )
        self.make_button(
            WIDTH_WINDOW - 250,
            40 + 15,
            200,
            40,
            "Compilar y Entrenar",
            func=lambda: self.show_progress(
                40, 120, self.model_progresses_compile, self.threads_compile, "compile"
            ),
        )

    def show_progress(self, x, y, model_processes, threads, proccess):
        """Creates the bars of progress to show to the user the progreess.
        Threads implemented, each thread is used to set the progress bar 
        according to the advance of the compilation and training.

        Args:
            x (int): x position
            y (int): y position
            model_processes (list): contains the processes to be done.
            threads (object): threads to do the porgress bar.
            proccess (string): type of process.
        """
        global flag_dataset, flag_entrenado, flag_compilado, flag_evaluacion, menu, our_parser, ai_models

        # We define our CNN hyperparameters and instantiate:
        Malware_SNN_1 = NeuralNetwork(
            architecture=[],
            # Dataparser gives us methods to automatically calculate the input features and the unique class labels:
            input_size=our_parser.input_features,
            output_size=our_parser.unique_labels,
            epochs=3,
            name="LNN",
            verbose=True)

        Malware_SVM_1 = SupportVectorMachine(
            regularization=1.0, kernel='rbf',
            degree=3,
            gamma='scale',
            name="Support Vector Machine",
            verbose="True")

        Malware_GBM_2 = GradientBoostingMachine(
            name="GBM",
            verbose=True)

        # We create an array of models that contains the 2 neural networks we created above
        ai_models = []
        ai_models.append(Malware_SNN_1)
        ai_models.append(Malware_SVM_1)
        ai_models.append(Malware_GBM_2)

        for model in ai_models:
            model.compile()
        # Code to show the process of the process in turn.
        if (proccess == "train") or (proccess == "compile"):
            for i in range(0, len(ai_models)):
                model_processes.append(
                    ttk.Progressbar(
                        self.main_window,
                        orient=tk.HORIZONTAL,
                        length=WIDTH_WINDOW - 100,
                        mode="determinate",
                    )
                )
                model_processes[i].place(x=x, y=y + 70 * i)
                model_processes[i]["value"] = 50
                self.make_label(
                    x,
                    (y - 30) + 70 * i,
                    WIDTH_WINDOW - 100,
                    50,
                    text=ai_models[i].name,
                    background="white",
                    font=("Arial", 11),
                )

            self.main_window.update()
            i = 0
            # We start the training process for al models.
            for model in ai_models:
                model.train(
                    training_data=our_parser.training_data,
                    training_labels=our_parser.training_labels,
                )
                # Setting the steps with threads.
                thread = Thread(target=self.step, args=(i, model_processes))
                threads.append(thread)
                i = i + 1

            for j in threads:
                j.start()

            flag_dataset = True
            flag_compilado = True
            flag_entrenado = True
            flag_evaluacion = False

            self.make_image(160, 35, "./Images/check_small.png")

            menu.check_steps()

    def step(self, i, model_processes):
        """Used to control the process of charge of the bar progress
        according to the process executed.
        """
        try:
            while model_processes[i]["value"] < 99:
                model_processes[i]["value"] += 1 * random.randint(0, 9)
                self.main_window.update_idletasks()
                time.sleep(0.05 * random.randint(0, 9))
        except:
            x = [i for i, a in locals().items() if a == model_processes][0]
            print("Bad Execcution, Thread " + str(i) + " Stopped (" + x + ")")

# Class to create the Evaluation window, inherit from Secondary_window,
# show information of the process, and create the plots of the stadistics of the process.


class Evaluate_window(Secondary_window):
    def __init__(self, title, color):
        Secondary_window.__init__(self, title, color)
        self.provisional_height = HEIGHT_WINDOW
        self.provisional_width = WIDTH_WINDOW + 200 * (len(ai_models) + 1)
        self.main_window.configure(
            height=self.provisional_height, width=self.provisional_width, bg=color
        )
        self.load_widgets()

    def generate_plots_times(self, ai_model):
        """generates the plot of the time spanned in the training and
        evaluation process.

        Args:
            ai_model (object): contains information of the model.
        """
        data = {
            "Entrenamiento": ai_model.training_time,
            "Evaluacion": ai_model.evaluation_time,
        }
        # Setting the labels and bars.
        fig = plt.figure(figsize=(10, 5))
        plt.bar(list(data.keys()), list(data.values()), width=0.4)
        plt.xlabel("Tipo")
        plt.ylabel("Tiempo (Segundos)")
        plt.title("Tiempo entrenamiento vs evaluación:" + ai_model.name)
        DPI = fig.get_dpi()
        fig.set_size_inches(460.0 / float(DPI), 300.0 / float(DPI))
        # We save the figure to use it after in the plot window.
        fig.savefig("Images/graph-" + ai_model.name +
                    "-times.png", bbox_inches="tight")
        
        
    def generate_plot_training_time(self):
        """Creates the plot of the accuracy of each model, which will be
        saved to use it later.
        """
        global ai_models

        data = {}
        # We use a dictionary to save the data of the accuracy from the models.
        for model in ai_models:
            data[model.name] = model.training_time
        # Setting the plot's data.
        fig = plt.figure(figsize=(6 * len(ai_models), 5))
        plt.bar(list(data.keys()), list(data.values()), width=0.5)
        plt.xlabel("Modelo")
        plt.ylabel("Tiempo (Segundos)")
        plt.title("Tiempo de Entrenamiento de Algoritmos de AI")
        DPI = fig.get_dpi()
        fig.set_size_inches(500.0 * len(ai_models) /
                            float(DPI), 450.0 / float(DPI))
        # We save the figure to use it after in the plot window.
        fig.savefig("Images/graph-training-time.png", bbox_inches="tight")
        
        
    def generate_plot_evaluation_time(self):
        """Creates the plot of the accuracy of each model, which will be
        saved to use it later.
        """
        global ai_models

        data = {}
        # We use a dictionary to save the data of the accuracy from the models.
        for model in ai_models:
            data[model.name] = model.evaluation_time
        # Setting the plot's data.
        fig = plt.figure(figsize=(6 * len(ai_models), 5))
        plt.bar(list(data.keys()), list(data.values()), width=0.5)
        plt.xlabel("Modelo")
        plt.ylabel("Tiempo (Segundos)")
        plt.title("Tiempo de Evaluación de Algoritmos de AI")
        DPI = fig.get_dpi()
        fig.set_size_inches(500.0 * len(ai_models) /
                            float(DPI), 450.0 / float(DPI))
        # We save the figure to use it after in the plot window.
        fig.savefig("Images/graph-evaluation-time.png", bbox_inches="tight")
        


    def generate_plot_accuracy(self):
        """Creates the plot of the accuracy of each model, which will be
        saved to use it later.
        """
        global ai_models

        data = {}
        # We use a dictionary to save the data of the accuracy from the models.
        for model in ai_models:
            data[model.name] = model.accuracy
        # Setting the plot's data.
        fig = plt.figure(figsize=(6 * len(ai_models), 5))
        plt.bar(list(data.keys()), list(data.values()), width=0.5)
        plt.xlabel("Modelo")
        plt.ylabel("Precisión")
        plt.title("Precisión de Algoritmos de AI")
        DPI = fig.get_dpi()
        fig.set_size_inches(500.0 * len(ai_models) /
                            float(DPI), 450.0 / float(DPI))
        # We save the figure to use it after in the plot window.
        fig.savefig("Images/graph-accuracy.png", bbox_inches="tight")

    def window_plots_show(self):
        """Creates a window to show the plots created in the previous methods.

        Returns:
            window: the window with the plots.
        """
        window = Plot_window("Graficos - Resultados", "#ECECEC")
        return window

    def load_widgets(self):
        """Sets the user interface.
        """
        global menu, flag_evaluacion, ai_models

        # We determine their accuracy given testing samples
        for model in ai_models:
            model.evaluate(
                our_parser.generate_testing_samples(sample_size=300))

        self.make_label(
            40,
            40,
            WIDTH_WINDOW - 100,
            50,
            text="Evaluación",
            background="white",
            font="Arial 12 bold",
        )

        self.make_button(
            self.provisional_width - 130,
            self.provisional_height - 65,
            100,
            40,
            "Salir",
            self.exit,
        )

        self.make_button(
            50,
            self.provisional_height - 65,
            160,
            40,
            "Ventana: Grafico",
            self.window_plots_show,
        )

        for i in range(0, len(ai_models)):
            self.make_label(
                500 * i + 50,
                120,
                self.provisional_width - 100,
                50,
                text=ai_models[i].name,
                background="white",
                font="Arial 12 bold",
            )

            self.generate_plots_times(ai_models[i])

            self.make_label(
                500 * i + 50,
                180,
                self.provisional_width - 100,
                50,
                text="Tiempo de Entrenamiento: "
                + str(ai_models[i].training_time)
                + " seg",
                background="white",
                font="Arial 11 bold",
            )

            self.make_label(
                500 * i + 50,
                230,
                self.provisional_width - 100,
                50,
                text="Tiempo de Evaluación: "
                + str(ai_models[i].evaluation_time)
                + " seg",
                background="white",
                font="Arial 11 bold",
            )

            self.make_label(
                500 * i + 50,
                280,
                self.provisional_width - 100,
                50,
                text="Precisión del Modelo: " + str(ai_models[i].accuracy),
                background="white",
                font="Arial 11 bold",
            )

            self.make_label(
                500 * i + 50,
                330,
                self.provisional_width - 100,
                50,
                text="Memoria consumida: " +
                str(sys.getsizeof(ai_models[i])) + " MB",
                background="white",
                font="Arial 11 bold",
            )

        self.generate_plot_accuracy()
        self.generate_plot_evaluation_time()
        self.generate_plot_training_time()

        flag_evaluacion = True
        menu.check_steps()

# Class used to show the plots created in the class Evaluate_window.
# The plots are saved in the folder of the project so we don´t need to connect the classes.


class Plot_window(Secondary_window):
    def __init__(self, title, color):
        Secondary_window.__init__(self, title, color)
        self.provisional_height = HEIGHT_WINDOW + 150
        self.provisional_width = WIDTH_WINDOW + 200 * (len(ai_models) + 1)
        self.main_window.configure(
            height=self.provisional_height, width=self.provisional_width, bg=color
        )
        self.load_widgets()

    def clear_frame(self):
        """Clears the frame according to the selection of the user 
        to change from one plot to other.
        """
        for widgets in self.main_window.winfo_children():
            widgets.destroy()

    def show_plot_times(self):
        """Clears the frame, and charges the widgets to show the times plot.
        """
        global ai_models
        self.clear_frame()
        self.load_widgets()
        # Selects the plot from the folder and selects the info from the global ai_models.
        for i in range(0, len(ai_models)):
            self.make_image(
                500 * i + 50, 50, "./Images/graph-" +
                ai_models[i].name + "-times.png"
            )
            self.make_label(
                500 * i + 50,
                390,
                self.provisional_width - 100,
                50,
                text="Tiempo de Entrenamiento: "
                + str(ai_models[i].training_time)
                + " seg",
                background="white",
                font="Arial 11 bold",
            )

            self.make_label(
                500 * i + 50,
                440,
                self.provisional_width - 100,
                50,
                text="Tiempo de Evaluación: "
                + str(ai_models[i].evaluation_time)
                + " seg",
                background="white",
                font="Arial 11 bold",
            )
            
    def show_plot_times_training(self):
        """Clears the frame, and charges the widgets to show the times plot.
        """
        global ai_models
        self.clear_frame()
        self.load_widgets()
        # Selects the plot from the folder and selects the info from the global ai_models.
        self.make_image(50, 50, "./Images/graph-training-time.png")
        for i in range(0, len(ai_models)):
            self.make_label(
                930,
                220 + i * 50,
                self.provisional_width - 100,
                50,
                text="T. Entrenamiento : "
                + ai_models[i].name
                + ": "
                + str(ai_models[i].training_time)[0:5] + " seg",
                background="white",
                font="Arial 11 bold",
            )
            
    def show_plot_times_evaluation(self):
        """Clears the frame, and charges the widgets to show the times plot.
        """
        global ai_models
        self.clear_frame()
        self.load_widgets()
        # Selects the plot from the folder and selects the info from the global ai_models.
        self.make_image(50, 50, "./Images/graph-evaluation-time.png")
        for i in range(0, len(ai_models)):
            self.make_label(
                930,
                220 + i * 50,
                self.provisional_width - 100,
                50,
                text="T. Entrenamiento : "
                + ai_models[i].name
                + ": "
                + str(ai_models[i].evaluation_time)[0:5] + " seg",
                background="white",
                font="Arial 11 bold",
            )
    def show_plot_accuracy(self):
        """Clears the frame, and charges the widgets to show the accuracy plot.
        """
        self.clear_frame()
        self.load_widgets()
        self.make_image(50, 50, "./Images/graph-accuracy.png")
        for i in range(0, len(ai_models)):
            self.make_label(
                930,
                220 + i * 50,
                self.provisional_width - 100,
                50,
                text="Precisión - : "
                + ai_models[i].name
                + ": "
                + str(ai_models[i].accuracy)[0:5],
                background="white",
                font="Arial 11 bold",
            )

    def load_widgets(self):
        self.make_button(
            50,
            self.provisional_height - 65,
            160,
            40,
            "Grafico: Tiempos",
            self.show_plot_times,
        )
        
        self.make_button(
            250,
            self.provisional_height - 65,
            160,
            40,
            "Grafico: Tiempos Entrenamiento",
            self.show_plot_times_training,
        )
        
        self.make_button(
            450,
            self.provisional_height - 65,
            160,
            40,
            "Grafico: Tiempos Evaluación",
            self.show_plot_times_evaluation,
        )

        self.make_button(
            650,
            self.provisional_height - 65,
            160,
            40,
            "Grafico: Precisión",
            self.show_plot_accuracy,
        )

        self.make_button(
            self.provisional_width - 130,
            self.provisional_height - 65,
            100,
            40,
            "Salir",
            self.exit,
        )


def main():
    global menu
    menu = Main_window(
        "Clasificación de Malware Mediante Deep Learning", "#ECECEC")
    menu.mainloop()


if __name__ == "__main__":
    main()
